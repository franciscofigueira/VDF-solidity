// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

interface IVDF{
    function requestRandom() external returns(uint256);
    function removeFunding(uint256 amount) external;
}

/**
    @title Example contract of using the RandomnessProvider contract. This contract implements a simple game of coinFlip
 */
contract RandomnessConsumer{

    IVDF immutable randomnessProvider;

    struct Game{
        address player;
        uint64 numFlips;
        bool isTails;
    }

    mapping(uint256 => Game) public games;

    event GameInitiated(address indexed player, uint256 requestID, bool playerPick, uint64 numGames);
    event GameOutcome(address indexed player, uint256 requestID, bool playerPick , bool[] coinOutcome);

    error InvalidNumFlips(uint64 input, uint64 max);
    error OnlyRandomnessProvider(address provider, address sender);
    error TransferFailed();

    constructor(address random){
        randomnessProvider = IVDF(random);
    }

    /**
        @dev request to make a game of coin flip, a request will be made to the randomness provider contract, make sure that this contract is funded
        @param numFlips number of times to flip a coin, between 1-10
        @param isTails player guess of wether it will be heads or tails
     */
    function flipCoin(uint64 numFlips, bool isTails) external{
        if(numFlips > 10 || numFlips < 1){
            revert InvalidNumFlips(numFlips, 10);
        }
        uint256 requestID = randomnessProvider.requestRandom();
        games[requestID] = Game(msg.sender,numFlips, isTails);
        emit GameInitiated(msg.sender, requestID, isTails, numFlips);
    }

    /**
        @dev function called by the randomnessProvider with the random number
        @param requestID ID of the request to identidy the game
        @param randomNumber random number generated by the VDF
     */
    function fulfillRandomness(uint256 requestID, uint256 randomNumber) external{
        if(msg.sender != address(randomnessProvider)){
            revert OnlyRandomnessProvider(address(randomnessProvider), msg.sender);
        }

        Game memory game = games[requestID];
        delete(games[requestID]);
  
        bool[] memory coinOutcomes = new bool[](game.numFlips);
       
        for(uint256 i = 0; i < game.numFlips; i++){
            uint256 random = uint256(keccak256(abi.encodePacked(randomNumber,i)))%2;
            if (random == 0){
                coinOutcomes[i] = true;
            }else{
                coinOutcomes[i] = false;
            }           
        }

        emit GameOutcome(game.player, requestID, game.isTails, coinOutcomes);
    }

    /**
        @dev example function to remove funds from the RandomnessProvider Contract
        @param amount ETH amount to remove
     */
    function removeRandomnessFunds(uint256 amount) external{
        randomnessProvider.removeFunding(amount);
        (bool success,) =  payable(msg.sender).call{value: address(this).balance}("");
        if(!success){
            revert TransferFailed();
        }
    }

    receive() external payable {}
}